Taskbar toggle utility for programmatic control of "Automatically hide the taskbar in desktop mode" with a keyboard shortcut

===

I want you to implement the "tb" tool.
The tool should be a standalone exe that has a command line parser with --version and --help and the default no-args behaviour is to launch an app that hides its default console and has a system tray icon with an exit, about, 

I'll dictate it to you.I'll dictate it to you.
So the entire purpose of the app is that when I hit control shift B or like Windows shift B it willtoggle the taskbar.andIt should have a system tray icon and that icon will have a right click context menu and in that context menu we will have multiple options. One of them will be the exit option, one of them will be a about option and the about option will show a message box that contains the version of the program and the git revisionAnd...the button and the show logs will make the console appear this has been demonstrated in the ping app and in the rusttemplates that I made for Windows.And I have these existing projects that contain a lot of this functionality, but...The creation of this new tool will reveal some gaps probably in the area of the keyboard listening, because I haven't done much of that yet. So as we are building wrappers on top of the Windows crate, we're putting them inside the Teamy Rust Windows utils project.that keeps the pieces that we're developing to be reusable.more easily.The Commanding Parsing should be done by Facet and Figu.There it is, just pronounced fig.and theWith the keyboard listening we should take inspiration frompower toys wherekeyboard shortcut is customizable and there's a checkbox for if theevent listener for the keyboard should be in raw mode so if you're not listening in raw mode then when another application tries to suppress the keyboard inputs you won't be able to read it so we want to have control over the way we're  reading these keyboard inputs to be that we can either allow our app to be suppressed by something like power toys or we want to bypass any suppression in case we are suppressing other applications default behavior and we want our behavior to take priority.It might be the case that this task of binding that keyboard sequence to the action of toggling the taskbar visibilityis something that could be accomplished with power toys. However, we wish toproceed with our own implementation while leaving it obvious in our read me and stuff that there may be a better alternative.I imagine this entire script could be done in something like auto hotkey.I prefer it to be in Rust.So if we imagine the development cycle of this tool, it's not going to go from 0 to 100. We're going to have incremental steps. So the order in which I expect this thing to be developed is first we start with the basic command line argument parsing. So that'll be something that we have reference for. In the teamy-rest-cli repo on the facet branch, I have the latest strategy that I've been doing for that. And in theCLI program for SFM propagate changes I have additional demonstration on it in useSo the first thing that would start with would be the CLI and then we'd have dash dash help working and dash dash version and we would want dash dash version to show the current version of the cargocreate that is our application in addition to using build.rs to get the git revision. So that's also in the examples.And...one get the cli so that also includes setting up our error handling with color irethe ire crate. ire=eyre, voice2text doesn't get it always

we have all these preferred defaults then the next step is going from no CLI to having a CLI which we just did and the next step from that is going froma CLI to also having a system tray.

the statefulness of the system tray is such that as we interact with the program we may be adjusting the state. So before we get to the system tray actually we want to make sure we have ourhome and cache directories configured so that's also part of the template CLI and that is locations for us to obviously save long-term settings or save things that areintermediate artifacts that don't need to be in the roaming app data.So with our CLI, after we have help inversion, we have the home and the cache commands to just print the paths of those locations.and then we can do.system tray.So we'll need an icon for the system tray, which the examples have a PNG that we can replace later. So in the list of actions that a human would need for this project, orThe list of actions in general because this could be done through generative means is the PNG icon that will represent this application.There are also programmatic generation methods where instead of aimage generator model. It is a text model that controls aprocess that consumes text to generate images.could render SVG.and then take a screenshot or an equivalent of rendering it to PNG.So we have a system tray icon.And when we right click, we want a context menu to appear. And in the context menu, we'll have an exit option and that will close the application.and then we'll have aAbout option which will do a dialog box that displays the same thing as dash dash version and also has a button that will copy that text to the clipboard.There might be existing clipboard logic in the teamy rust windows.then we want aoption in the context menu for picking the sound that we'll play so when we detect the keyboard shortcuta sound that we play and there's examples of that in the ping application.And that's ping with two eyes. And then we'll have...the context menu when you hover over it it'll pop out another menu and that menu will have aof choices.So it'll have a history of the previous version.So in thething when we right-click the tray icon and then we select sound thenRadio list where one of the options at the top is no sound and then below that isthe history ofrecent sounds.There's also a pick new sound optionpick new sound, no sound, or then one of the previous sounds.I can maybe add some...horizontal lines or separators if that's possible.and then we willhave when the user picks the new sound option it will open afile picker.filters too.sound extensions but also allows the user to change the filter to the asterisk to show all files.And...We will make sure that when the app starts, it plays a quiet sound to get it to show up in the volume mixer.We'll also want to make sure we have whatevercontrol C behavior is needed toget the system tray icon to hide when the app exits gracefully.So it might not be a control C thing, but we need to make sure we're

And then from there... There's a keyboard shortcuts option in the context menu.so when you hover over that we'll get another menu that has atext line grade out whatever that is the display for what the current keyboard shortcut is and there's aoption to change the shortcut and when you click on that option it willopen a window whereThere's a button in the window and when you click the buttonstarts grabbing keyboard input and listens forkey press sequences.and displays it. So it's like the keyboard shortcut thing. So when you clickand you focus this element so I guess instead of having a button we just have a window that when the window is focusedIt will.a listening mode where we capture the keyboard inputsand we capture it usingthe same handler that we're listening to them for. So this is something that can listen while the window is not focused in order to perform the Control-Shift-B keyboard action to hide the taskbar.But in the process of activating the binding mode, we also want to not use the Windows keyboard.listening behavior. We want to use our global listening behavior.And...Actually...That's probably not true.What we can say for certain is that there is a state in which we are currently modifying a keyboard shortcut.that is being used by the preview mechanism.There is.a separate action that issaving the new keyboard shortcut. So if we consider that each action that we're going to be doing with the UI is something that we would also want a CLI command for, then we must clearly state out the actions we're trying to do.sound management, so we'd have a sound CLI subcommand for sound.list set.a solicit command, so we'd have atb.exe sound solicit command where it wouldPerform the dialog box option.that prompts the user and echoes the path.so that you can almostbuild this application byhaving something else drive the UI for it.From the command line you can configure this using not just text editing on config files but there is a formal command line for all the CRUD operations needed to change the keyboard shortcut and thesound that plays whether or not that sound is enabled or not.and the history ofthe history of.Keyboard shortcuts because why notwhich means thatbecause thesystem tray icon is.a large amount of complexity.if we focus on the CLI use case first and then tack on thesystem tray to basically just be calling the functions that are CLI maps toif we're thinking about...this thing working, then the system tray is a lot lower priority.the core functionality.So if we consider polish versus non-polish, what's the MVP of this app?is we want just the CLI.So if we're planning in the session to get the MVP and then the polish we want toGet started. I think this is sufficient information